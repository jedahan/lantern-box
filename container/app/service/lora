#!/usr/bin/env python2
from __future__ import print_function
import sys
import string
import time
import signal
import logging
import os
import yaml

from threading import Timer
from persistqueue import UniqueQ
import rf95

DO_SEND = True
DO_RECEIVE = True
DEFAULT_LORA_FREQUENCY = rf95.CH_10_US # 924.68 MHz
LORA_POWER = 20
SEND_INTERVAL = 3 # how many seconds should we wait between messages
LORA_MODEM_CONFIG = (0x78, 0xc4, 0x0C)  # slow and long-range with AGC

#-----------------------------------------------------------------------------
class RepeatedTimer(object):
    def __init__(self, interval, function, *args, **kwargs):
        self._timer     = None
        self.interval   = interval
        self.function   = function
        self.args       = args
        self.kwargs     = kwargs
        self.is_running = False

    def _run(self):
        self.is_running = False
        self.start()
        self.function(*self.args, **self.kwargs)

    def start(self):
        if not self.is_running:
            self._timer = Timer(self.interval, self._run)
            self._timer.start()
            self.is_running = True

    def stop(self):
        self._timer.cancel()
        self.is_running = False
        


#-----------------------------------------------------------------------------
lora = rf95.RF95(0, 25, None, 13)
did_init = False
is_running_queue = False

is_closing = False
inbox = UniqueQ("/opt/lantern/inbox")
logging.basicConfig(filename="/opt/lantern/logs/lora.log", level=logging.DEBUG)


#-----------------------------------------------------------------------------
def printNow(str):
    print(str)
    logging.info(str)
    sys.stdout.flush()

def isLoRaBusy():
    lora.spi.open(0,lora.cs)
    current_mode = lora.spi_read(rf95.REG_01_OP_MODE)
    if (current_mode >= 128):
        return True

# for now, some updates will be missed when we're sending out data
def checkForIncoming():
    # Wait until data is available 
    while is_running_queue or not lora.available() or is_closing:
        pass
    # Receive
    payload_size = lora.buflen
    data = lora.recv()
    print("-----------------")
    print("receiving:")
    final_str = ""
    for i in data:
        print(chr(i), end="")
        final_str += chr(i)
    print("\nbytes received: " + str(payload_size))
    printNow("-----------------")
    inbox.put(final_str)

def checkForOutgoing():
    global is_running_queue
    # skip timer runs if we're still processing a queue
    if not is_running_queue:

        is_running_queue = True

        outbox = UniqueQ("/opt/lantern/outbox")
        to_process = len(outbox)

        if to_process > 1:
            printNow("queue to process:" + str(to_process) + "\n\n")
            
        while to_process > 0:
            if len(item):
                print("-----------------")
                printNow("sending: "   + item)
            item = outbox.get()
                lora.send(lora.str_to_data(item))
                lora.wait_packet_sent()
                payload_size = len(item.encode("utf8"))
                print("bytes sent: " + str(payload_size))
                printNow("-----------------")
            else:
                printNow("skipping empty message")
            to_process -= 1
            if to_process > 0:
                printNow("remaining in queue: " + str(len(outbox)))
            time.sleep(SEND_INTERVAL)
            outbox.task_done()


        is_running_queue = False





#-----------------------------------------------------------------------------
def main():

    printNow("============================")
    printNow("  Lantern LoRa Service")
    printNow("============================")

    def exitGracefully():
        printNow("\nexiting gracefully...")
        is_closing = True
        if 'rt' in locals() and rt.is_running:
            rt.stop()
            printNow("halting send activity...")
        else:
            printNow("no send activity to halt...")
            
        lora.set_mode_idle()
        printNow("set lora to idle...")
        time.sleep(1)
        lora.led_off()
        printNow("running cleanup...")
        lora.cleanup()
        sys.exit()


    def handleStopSignals(signum, frame):
        exitGracefully()
    
    try:
        if isLoRaBusy():
            printNow("radio in use elsewhere...")
            quit(1)
        elif not lora.init(): # returns True if found
            print("radio not found or not ready. please adjust to CE0 or try later...")
            exitGracefully()
        else:
            # make sure we always exit gracefully when running as a service
            signal.signal(signal.SIGINT, handleStopSignals)
            signal.signal(signal.SIGTERM, handleStopSignals)
            did_init = True


            # determine which frequency to broadcast on
            try:
                y = yaml.load(open("/opt/lantern/config.yml"))
                freq = y["FREQUENCY"]
            except Exception,e:
                printNow("using default frequency...")
                freq = DEFAULT_LORA_FREQUENCY

            lora.set_frequency(freq)
            printNow("radio ready @ " + str(freq) + " MHz")


            # setup RF95/RF96 modem for our long-range, peer-to-peer data
            lora.set_tx_power(LORA_POWER)
            lora.set_modem_config(LORA_MODEM_CONFIG)
            printNow("waiting for outgoing messages in queue...")

            # use a timed interval to check our queue and send messages
            if DO_SEND:
                rt = RepeatedTimer(7, checkForOutgoing)
                rt.start()

            if DO_RECEIVE:
                # when we're not sending messags, drop into receiving mode
                printNow("watching airwaves for incoming messages...")
                while True:
                    checkForIncoming()

    except KeyboardInterrupt:
        exitGracefully()

if __name__ == '__main__':
    main()