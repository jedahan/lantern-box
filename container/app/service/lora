#!/usr/bin/env python2
from __future__ import print_function
import sys
import string
import time
import signal
import os
from threading import Timer
from persistqueue import FIFOSQLiteQueue

try:
    import rf95
except Exception,e:
    print("skipping lora for non-rpi interface...")
    sys.exit()

DO_SEND = True
DO_RECEIVE = True
LORA_FREQUENCY = rf95.CH_10_US # 924.68 MHz
LORA_POWER = 20
SEND_INTERVAL = 3 # how many seconds should we wait between messages
LORA_MODEM_CONFIG = (0x78, 0xc4, 0x0C)  # slow and long-range with AGC

#-----------------------------------------------------------------------------
class RepeatedTimer(object):
    def __init__(self, interval, function, *args, **kwargs):
        self._timer     = None
        self.interval   = interval
        self.function   = function
        self.args       = args
        self.kwargs     = kwargs
        self.is_running = False

    def _run(self):
        self.is_running = False
        self.start()
        self.function(*self.args, **self.kwargs)

    def start(self):
        if not self.is_running:
            self._timer = Timer(self.interval, self._run)
            self._timer.start()
            self.is_running = True

    def stop(self):
        self._timer.cancel()
        self.is_running = False
        


#-----------------------------------------------------------------------------
lora = rf95.RF95(0, 25, None, 13)
did_init = False
is_running_queue = False



#-----------------------------------------------------------------------------
def printNow(str):
    print(str)
    sys.stdout.flush()

def isLoRaBusy():
    lora.spi.open(0,lora.cs)
    current_mode = lora.spi_read(rf95.REG_01_OP_MODE)
    if (current_mode == 128 or current_mode == 129):
        return True

# for now, some updates will be missed when we're sending out data
def checkForIncoming():
    # Wait until data is available 
    while is_running_queue or not lora.available():
        pass
    # Receive
    payload_size = lora.buflen
    data = lora.recv()
    print("-----------------")
    print("receiving:")
    final_str = ""
    for i in data:
        print(chr(i), end="")
        final_str += chr(i)
    print("\nbytes received: " + str(payload_size))
    printNow("-----------------")
    cmd = "/opt/lantern/bin/process-message " + final_str
    run = os.system(cmd)
    print(run)

def checkForOutgoing():
    global is_running_queue
    # skip timer runs if we're still processing a queue
    if not is_running_queue:

        is_running_queue = True

        q = FIFOSQLiteQueue(path="/tmp/messages", multithreading=True)
        to_process = len(q)

        if to_process > 0:
            printNow("queue to process:" + str(to_process))
            
        while to_process > 0:
            item = q.get()
            if len(item):
                print("-----------------")
                printNow("sending: "   + item)
                lora.send(lora.str_to_data(item))
                lora.wait_packet_sent()
                payload_size = len(item.encode("utf8"))
                print("bytes sent: " + str(payload_size))
                printNow("-----------------")
            else:
                printNow("skipping empty message")
            to_process -= 1
            if to_process > 0:
                printNow("remaining in queue: " + str(len(q)))
            time.sleep(SEND_INTERVAL)
            q.task_done()


        is_running_queue = False


def exitGracefully():
    printNow("exiting gracefully...")
    lora.set_mode_idle()
    time.sleep(1)
    lora.cleanup()
    time.sleep(1)
    sys.exit()



#-----------------------------------------------------------------------------
def main():

    print("============================")
    print("  Lantern LoRa Service")
    printNow("============================")
    
    def handleStopSignals(signum, frame):
        if rt:
            rt.stop()
        exitGracefully()
    
    try:
        if isLoRaBusy():
            printNow("radio in use elsewhere...")
            quit(1)
        elif not lora.init(): # returns True if found
            print("radio not found or not ready. please adjust to CE0 or try later...")
            exitGracefully()
        else:
            # make sure we always exit gracefully when running as a service
            signal.signal(signal.SIGINT, handleStopSignals)
            signal.signal(signal.SIGTERM, handleStopSignals)
            did_init = True

            # setup RF95/RF96 modem for our long-range, peer-to-peer data
            lora.set_frequency(LORA_FREQUENCY)
            lora.set_tx_power(LORA_POWER)
            lora.set_modem_config(LORA_MODEM_CONFIG)
            printNow("radio ready @ " + str(LORA_FREQUENCY) + " MHz")
            printNow("waiting for outgoing messages in queue...")

            # use a timed interval to check our queue and send messages
            if DO_SEND:
                rt = RepeatedTimer(7, checkForOutgoing)
                rt.start()

            if DO_RECEIVE:
                # when we're not sending messags, drop into receiving mode
                printNow("watching airwaves for incoming messages...")
                while True:
                    checkForIncoming()

    except KeyboardInterrupt:
        exitGracefully()

if __name__ == '__main__':
    main()