#!/usr/bin/env node
var path = require("path");
var fs = require("fs");
var spawnSync = require('child_process').spawnSync;




//------------------------------------------------------------------------
var done = (function wait() { 
    if (!done) {
        setTimeout(wait, 1000)
    }
    else {
        log.info("closing service...\n");
        log.info("##############################################\n");
        setTimeout(process.exit, 100);
    }
})();

var broadcast_seq_rev; // used to keep track of our local document for sequence

var logger_opts = {
    logDirectory:'/opt/lantern/logs/',
    fileNamePattern:'broadcast-<DATE>.log',
    dateFormat:'YYYY.MM.DD'
};

var log = require('simple-node-logger').createRollingFileLogger( logger_opts );
log.info("##############################################");
log.info("Lantern Broadcast Service (" + getDeviceIdentifier() + ")");
log.info("##############################################\n");

var PouchDB = require("lantern-serve").PouchDB;
var db;



//------------------------------------------------------------------------

/**
* unique device identifier
*/
function getDeviceIdentifier() {
    try {
        var file_path = path.join(__dirname, "..", "node_modules", "lantern-serve", "conf", "lantern.json");
        var obj = JSON.parse(fs.readFileSync(file_path, 'utf8'));
        if (!obj.id) {
            throw new Error("Missing device identifier");
        }
        return obj.id;
    }
    catch(e) {
        log.error(e);
        done = true;
    }
}

/**
* push change over distributed long-range network
**/
function addMessageToQueue(msg) {
    if (!msg) return;
    log.info("sending message to queue: " + msg);
    var result = spawnSync(path.resolve(__dirname + "/../bin/queue-message"), [msg]);
    log.info(String(result.stdout));
}

/**
* let other lanterns know about a key/value change
**/
function notifyDocumentUpdate(doc) {
    var msg = buildParameters(doc);
    if (msg.length) {
        addMessageToQueue(doc._id + "?" + msg);
    }
}


/**
* let other lanterns know about a new document
**/
function notifyDocumentCreate(doc) {
    var msg = buildParameters(doc);
    addMessageToQueue(doc._id + "?" + msg);
}


/**
* let other lanterns know about a removed document
**/
function notifyDocumentRemove(doc_id) {
    addMessageToQueue(doc_id);
}

/**
* let other lanterns know this device is online
**/
function notifyLanternOnline() {
    setTimeout(function() {
        var id = getDeviceIdentifier();
        db.get("d:"+id).then(function(doc) {
            addMessageToQueue(doc._id + "?st=" + doc.st + "&tt=" + doc.tt);
        })
        .catch(function(err) {
            log.error(err);
            log.error("missing lantern id");
        });

    }, 15000*Math.random());
}

/**
* check for updates since last broadcast revision
*/
function checkForChanges(since) {

    log.info("find changes since: " + since);

    return db.changes({
            since: Number(since),
            include_docs: true,
            limit: 20
        })
        .then(function(data) {
            if (data.results.length == 0 ) {
                log.info("no changes since " + since);
            }
            else {
                data.results.forEach(onChange);
            }
            return data.last_seq;
        })
        .then(saveSince)
        .catch(function(err) {
            log.error(err);
            log.error("failed, exit anyway...");
            done = true;
        });

}

/**
* construct a query-string style list of key/value pairs
*/
function buildParameters(doc) {
    var params = [];
    for (var k in doc) {
        // ignore private keys and reserved _ namespace items when sending
        if (k[0] != "_" && k[0] != "$") {
            var val = doc[k];

            if (typeof val === 'number') {
                val = "#"+val;
            }
            else if (val instanceof Array) {
                val = ","+val.join(",");
            }
            else if (typeof(val) == "object") {
                val = JSON.stringify(val);
            }
            params.push(k+"="+val);
        }
    }
    return params.join("&");
}


/**
* handler to process any document change in local lantern database
**/
function onChange(change) {
    var msg = "";
    for (var idx in change.changes) {
        var doc = change.doc;
        var rev = change.changes[idx].rev;

        if (doc._deleted) {
            // @todo notify once we can isolate most meaningful deletes
            log.info("cowardly refusing to send delete over network, for now...");
            return;
            //notifyDocumentRemove(doc._id);
        }
        // filters out changes made from LoRa to prevent echo
        else if (doc.$ra) {

            if (doc.hasOwnProperty("$ua")) {
                var updated_at = new Date(doc.$ua).getTime();
                var received_at = new Date(doc.$ra).getTime();
                if (updated_at <= received_at) {
                    log.info("skip " + doc._id + " received by radio");
                    return;
                }
                else {
                    log.info("updating doc received from another lantern");
                }
            }

        }

        log.info("====== " + doc._id + "======");

        log.info(change.doc);

        // push change over distributed long-range network
        if(doc._rev[0] == "1" && doc._rev[1] == "-") {
            // assume document has been created if we're at first revision
            notifyDocumentCreate(doc);
        }
        else {
            notifyDocumentUpdate(doc);
        }
        log.info("\n\n\n");
    }
}


function getUpdateSeq() {
    return db.info().then(function(res) {
        return res.update_seq;
    });
}

function saveSince(since) {

    if (since == undefined) {
        log.warn("Skipping without required: since");
        return;
    }

    var doc = {
      _id: '_local/broadcast_seq',
      since: since,
      updated_at: new Date()
    }

    if (broadcast_seq_rev) {
        doc._rev = broadcast_seq_rev;
    }

    return db.post(doc)
        .then(function(res) {
            log.debug(res);
            broadcast_seq_rev = res.rev;
            return since;
        })
        .catch(function(err) {
            log.error(err);
        })
}

//------------------------------------------------------------------------
/**
* start listening for changes
**/


db = new PouchDB("http://localhost/db/lnt/");;

getUpdateSeq()
    .then(function(update_seq) {
        return db.get("_local/broadcast_seq").then(function(doc) {
            broadcast_seq_rev = doc._rev;
            if (!doc.hasOwnProperty("since")) {
                return saveSince(update_seq).then(checkForChanges);
            }
            else {
                return checkForChanges(doc.since);
            }
        })
        .catch(function(err) {
            if (err.name == "not_found") {
                log.info("no stored update sequence. mapping to current database last_seq...");
                return saveSince(update_seq).then(checkForChanges);
            }
            else {
                log.error(err);
            }
        });
    })
    .then(function() {
        done = true;
    })
    .catch(function(err) {
        log.error(err);
        done = true;
    })

