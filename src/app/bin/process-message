#!/usr/bin/env node

if (process.argv.length != 3) {
    console.log("This program requires one and only one argument to run");
    process.exit();
}

var logger_opts = {
    logDirectory:'/opt/lantern/logs/',
    fileNamePattern:'inbox-message-<DATE>.log',
    dateFormat:'YYYY.MM.DD'
};

var log = require('simple-node-logger').createRollingFileLogger( logger_opts );


//----------------------------------------------------------------------------

var db;
var input_str = process.argv[2];


function processCreate(doc) {
    log.info("CREATE DOC ", doc);
    return db.post(doc).then(function(results) {
        log.info(results);
    })
    .catch(function(err) {
        log.info(err);
        process.exit();
    });
}

function processUpdate(doc) {
    db.get(doc._id).then(function(existing_doc) {
        log.info("found document. merging...");
        for (var idx in doc) {
            existing_doc[idx] = doc[idx];
        }

        // note: may be inaccurate due to offline system clock
        var now = new Date();

        if (existing_doc.hasOwnProperty("$ua") && now.getTime() > new Date(existing_doc.$ua).getTime()) {
            existing_doc.$ua = new Date();
        }

        log.info("UPDATE TO DOC", existing_doc);

        return db.post(existing_doc)
            .then(function(results) {
                log.info(results);
                process.exit();
            });
    })
    .catch(function(err) {
        if (err.status == 404) {
            processCreate(doc);
        }
        else {
            log.info(err);
            process.exit();
        }
    });
}

function processDelete(doc) {
    log.info("DELETE DOC ", doc);

    db.get(doc._id).then(function(existing_doc) {
        log.info("found document. removing...");
        doc._rev = existing_doc._rev;
        return db.remove(doc).then(function(results) {
            log.info(results);
            process.exit();
        });
    })
    .catch(function(err) {
        if (err.status == 404) {
            log.info("can't update non-existing document");
            process.exit();
        }
        else {
            log.info(err);
            process.exit();
        }
    });
}



//----------------------------------------------------------------------------

var input = input_str.replace(/\^+/, '\x01').split('\x01');
if (input.length == 2) {
    // update
    var PouchDB = require("lantern-serve").PouchDB;
    db = new PouchDB("http://localhost/db/lnt/");
    
    var id = input[0];
    var msg = input[1];
    var parts = msg.split("?");

    log.info("message id = " + id);

    // begin constructing doc based on message
    var doc = {
        _id: parts[0],
        $rx: true // document received by long-range radio, don't push back out
    };

    var keys = parts[1];
    if (keys) {
        log.info(keys);
        var key_parts = keys.split("&");
        log.info(key_parts);

        key_parts.forEach(function(part) {

            var item = part.split("=");
            var k = item[0];
            var v = item[1];

            // double-check to make sure we don't process $key or _key
            if (k[0] == "$" || k[0] == "_") {
                return;
            }

            v = decodeURIComponent(v);

            // is this a comma-separated list? if so, assume array
            if (v[0] == ",") {
                doc[k] = new Array();
                v.split(",").forEach(function(val) {
                    if (val) doc[k].push(val);
                });
            }
            // is this a number?
            else if (v[0] == "#") {
                doc[k] = Number(v.substr(1, v.length-1));
            }
            else {
                doc[k] = v;                
            }




        });
            
        doc.$ra = new Date();
        processUpdate(doc);
    }
    else {
        // no data means we want to delete the doc
        processDelete(doc);
    }
}
else {
    log.info("ignoring message: " + input);
    process.exit();
}