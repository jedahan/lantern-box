#!/usr/bin/env node
var path = require("path");
var fs = require("fs");
var spawn = require('child_process').spawn;
var PouchDB = require("lantern-serve").PouchDB;


var ping_interval = 15 * 1000; // every 30s+random tell other lanterns we exist

//------------------------------------------------------------------------

/**
* use MAC address to identify device uniquely
*/
function getDeviceIdentifier() {
    var address;
    try {
        // default to wlan0 MAC Address
        address = fs.readFileSync("/sys/class/net/wlan0/address");
    }
    catch(e) {
        // fall-back to ethernet MAC Address
        // may be used for docker-based virtual machines
        address = fs.readFileSync("/sys/class/net/eth0/address");
    }
    var id = String(address).trim().split(":");
    return id[0] + id[id.length-1];
}

/**
* push change over distributed long-range network
**/
function addMessageToQueue(msg) {
    if (!msg) return;

    var program = spawn(path.resolve(__dirname + "/../bin/queue-message"), [msg]);

    program.stdout.on('data', function (data) {
        console.log("[broadcast] " + data.toString());
    });

    program.stderr.on('data', function (data) {
      console.log('[broadcast] q err: ' + data.toString());
    });
}

/**
* let other lanterns know about a key/value change
**/
function notifyDocumentUpdate(doc) {
    var msg = buildParameters(doc);
    if (msg.length) {
        addMessageToQueue(doc._id + "?" + msg);
    }
}


/**
* let other lanterns know about a new document
**/
function notifyDocumentCreate(doc) {
    var msg = buildParameters(doc);
    addMessageToQueue(doc._id + "?" + msg);
}


/**
* let other lanterns know about a removed document
**/
function notifyDocumentRemove(doc_id) {
    addMessageToQueue(doc_id);
}

/**
* sometimes let other lanterns know this device is online
**/
function notifyLanternOnline() {
    if (Math.random() > 0.3) {
        setTimeout(function() {
            var id = getDeviceIdentifier();
            if (!id) {
                console.log("[broadcast] missing lantern id");
            }
            else {
                addMessageToQueue("d:"+ id + "?st=1");
            }
        }, 15000*Math.random());
    }
}

/**
* construct a query-string style list of key/value pairs
*/
function buildParameters(doc) {
    var params = [];
    for (var k in doc) {
        // ignore private keys and reserved _ namespace items when sending
        if (k[0] != "_" && k[0] != "$") {
            var val = doc[k];
            if (val instanceof Array) {
                val = val.join(",");
            }
            else if (typeof(val) == "object") {
                val = JSON.stringify(val);
            }
            params.push(k+"="+val);
        }
    }
    return params.join("&");
}


/**
* handler to process any document change in local lantern database
**/
function onChange(change) {
    var msg = "";
    for (var idx in change.changes) {
        var doc = change.doc;
        var rev = change.changes[idx].rev;

        if (doc._deleted) {
            // @todo notify once we can isolate most meaningful deletes
            return;
            //notifyDocumentRemove(doc._id);
        }
        // filters out changes made from LoRa to prevent echo
        else if (doc.$ra) {
            console.log("[broadcast] skip " + doc._id + " received by radio");
            return;
        }
        else if (doc.$ia) {
            console.log("[broadcast] skip " + doc._id + " imported directly");
            return;
        }


        console.log(["======", doc._id, rev, "======"].join(" "));

        // push change over distributed long-range network
        if(!doc.$ra && doc._rev[0] == "1" && doc._rev[1] == "-") {
            // assume document has been created if we're at first revision
            notifyDocumentCreate(doc);
        }
        else if (!doc.$ra) {
            notifyDocumentUpdate(doc);
        }

        console.log(change);
        console.log("\n\n\n");
    }
}



//------------------------------------------------------------------------
/**
* start listening for changes
**/

console.log("[broadcast] about to watch for database changes...");


var db = new PouchDB("http://localhost/db/lantern/");
db.changes({
        live: true,
        since: 'now',
        retry: true,
        include_docs: true
    })
    .on('active', function() {
        console.log("[broadcast] active change feed");
    })
    .on('paused', function() {
        console.log("[broadcast] paused change feed");
    })
    .on('change', onChange)
    .on('error', function (err) {
        console.log(err);
    });

console.log("[broadcast] watching changes...");
setInterval(notifyLanternOnline, ping_interval);


